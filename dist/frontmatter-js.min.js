/*!
 * frontmatter-js 1.0.1 - a very simple frontmatter parser
 * Copyright 2020 worc <curtis.s.mcallister@gmail.com> - https://github.com/worc/frontmatter
 * License: ISC
 */
!function(t,n){"object"==typeof exports&&"object"==typeof module?module.exports=n():"function"==typeof define&&define.amd?define([],n):"object"==typeof exports?exports["frontmatter-js"]=n():t["frontmatter-js"]=n()}(window,(function(){return function(t){var n={};function e(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return t[i].call(r.exports,r,r.exports,e),r.l=!0,r.exports}return e.m=t,e.c=n,e.d=function(t,n,i){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:i})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(e.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var r in t)e.d(i,r,function(n){return t[n]}.bind(null,r));return i},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=0)}([function(t,n,e){"use strict";e.r(n);function i({frontmatter:t}){const n={},e=t.split(/\n/g).map(t=>t.trim()).filter(t=>t.length>0).map((t,n,e)=>({type:function({line:t,index:n,array:e,nextLine:i}){const r=t.startsWith(":"),o=t.includes(":"),s=t.endsWith(":"),a=t.startsWith("-"),l=void 0!==i&&i.startsWith("-"),u=e.slice(0,n);if(r)throw new Error(`\n      Metadata is missing a key in its key value pair:\n      \n      ${t}\n      \n      Metadata should have a key left of the colon:\n      \n        correct:\n          key: value\n        \n        incorrect:\n          : value\n    `);if(!o&&!a)throw new Error(`\n      Couldn't parse metadata:\n\n      ${t} \n\n      Metadata must either include a colon separator or start with a dash:\n\n        correct:\n          key: value\n          - list item\n          beginning of a list:\n\n        incorrect:\n          key value\n          list item\n          beginning of list\n    `);if(s&&!a&&!l)throw new Error(`\n      Couldn't parse metadata list:\n\n      ${t}\n        ${i}\n\n      Metadata lists must end with a colon and must be followed by metadata that starts with a dash (indentation doesn't matter):\n\n        correct:\n           beginning of list:\n           - list item\n\n           beginning of list:\n            - indented list item\n\n        incorrect:\n            beginning of list:\n            list item\n\n            beginning of list:\n              indented list item\n    `);if(a&&!function({previousLines:t}){return t.some(t=>t.endsWith(":"))}({previousLines:u}))throw new Error(`\n      List item is not part of a list:\n      \n      ${t}\n      \n      Lists items must follow the beginning of a list. Lists are started by omitting text after the colon (indentation doesn't matter):\n      \n        correct:\n          beginning of list:\n          - list item\n          - another list item\n          \n          beginning of list:\n            - first indented list item\n            - second indented list item\n          - an unindented list item mixed in\n          \n        incorrect:\n          beginning of list without a colon\n          - list item\n    `);return a?"list_item":s?"beginning_of_list":o&&!s?"key_value_pair":void 0}({line:t,index:n,array:e,nextLine:e[n+1]}),line:t}));let i="";return e.forEach(t=>{if("key_value_pair"===t.type){const e=t.line.split(":",2)[0].trim(),i=t.line.split(":").slice(1).join(":").trim();n[e]=i}if("beginning_of_list"===t.type&&(i=t.line.split(":",2)[0].trim(),n[i]=[]),"list_item"===t.type){const e=t.line.split("-").slice(1).join("-").trim();n[i].push(e)}}),n}function r({content:t}){if(!t.trim().startsWith("---"))throw new Error("\n      Frontmatter content must start with three dashes:\n      \n      ---\n      key: value\n      list:\n        - item one\n        - item two\n      ---\n    ");const n=new RegExp(/^---$/m),e=t.trim().split(n)[1],r=t.trim().split(n)[2].trim();return{frontmatter:i({frontmatter:e}),body:r}}e.d(n,"default",(function(){return r}))}])}));